(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{68:function(t,e,a){"use strict";a.r(e);var r=a(0),_=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1、html5-中-cookie-sessionstorage-和-localstorage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、html5-中-cookie-sessionstorage-和-localstorage"}},[t._v("#")]),t._v(" 1、HTML5 中 cookie,sessionStorage 和 localStorage")]),t._v(" "),a("blockquote",[a("p",[t._v("cookie 用来保存登录信息，大小限制为 4KB 左右"),a("br"),t._v("\nlocalStorage 是 Html5 新增的，用于本地数据存储，保存的数据没有过期时间，一般浏览器大小限制在 5MB"),a("br"),t._v("\nsessionStorage 接口方法和 localStorage 类似，但保存的数据的只会在当前会话中保存下来，页面关闭后会被清空")])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/cooke.png"),alt:"foo"}}),t._v(" "),a("p",[t._v("至Chrome 80版本升级后，Chrome 80开始执行新的Cookie策略，对未设置“SameSite”的Cookie默认其值为Lax，即三方网站如果使用了该资源，在请求中是不会带上相关的Cookie的；对SameSite设置为None的Cookie，要求必须同时设置Secure，否则拒绝此Cookie。")]),t._v(" "),a("h3",{attrs:{id:"名词解读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#名词解读"}},[t._v("#")]),t._v(" 名词解读")]),t._v(" "),a("h4",{attrs:{id:"cookie的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie的作用"}},[t._v("#")]),t._v(" cookie的作用")]),t._v(" "),a("p",[t._v("用于解决客户端与服务端会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。")]),t._v(" "),a("h4",{attrs:{id:"cookie中的samesite属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie中的samesite属性"}},[t._v("#")]),t._v(" cookie中的sameSite属性")]),t._v(" "),a("p",[t._v("作用：SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。\n属性值：")]),t._v(" "),a("blockquote",[a("p",[t._v("1、Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。"),a("br"),t._v("\n2、Lax 允许部分第三方请求携带 Cookie"),a("br"),t._v("\n3、None 无论是否跨站都会发送 Cookie")])]),t._v(" "),a("p",[t._v("Chrome80 之前默认是 None 的，Chrome80 后默认是 Lax。")]),t._v(" "),a("h3",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),a("h5",{attrs:{id:"_1、在请求中设置-samesite-为-none。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、在请求中设置-samesite-为-none。"}},[t._v("#")]),t._v(" 1、在请求中设置 SameSite 为 none。")]),t._v(" "),a("h5",{attrs:{id:"_2、采用同域，避开浏览器同源策略（sop），（1、资源处于同一台服务器，2、采用nginx代理处理成同域）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、采用同域，避开浏览器同源策略（sop），（1、资源处于同一台服务器，2、采用nginx代理处理成同域）"}},[t._v("#")]),t._v(" 2、采用同域，避开浏览器同源策略（SOP），（1、资源处于同一台服务器，2、采用nginx代理处理成同域）")]),t._v(" "),a("h2",{attrs:{id:"_2、进程和线程的理解？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、进程和线程的理解？"}},[t._v("#")]),t._v(" 2、进程和线程的理解？")]),t._v(" "),a("p",[a("strong",[t._v("进程")]),t._v("：cpu 的资源分配的最小单位。"),a("br"),t._v(" "),a("strong",[t._v("多进程")]),t._v("：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。")]),t._v(" "),a("p",[a("strong",[t._v("线程")]),t._v("：")]),t._v(" "),a("blockquote",[a("p",[t._v("一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；"),a("br"),t._v("\n进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。")])]),t._v(" "),a("p",[t._v("在浏览器的渲染进程中，主要存在一下几大线程。"),a("br"),t._v("\n1、GUI 线程(负责渲染浏览器界面 HTML 元素)"),a("br"),t._v("\n2、Javascript 引擎线程(负责处理 Javascript 脚本程序，与 GUI 线程互斥，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。)"),a("br"),t._v("\n3、事件触发线程（状态变更时，放入 JavaScript 引擎的处理队列中等待处理。）"),a("br"),t._v("\n4、定时器线程（浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。）"),a("br"),t._v("\n5、网络请求线程（状态变更时，放入 JavaScript 引擎的处理队列中等待处理。）")]),t._v(" "),a("h2",{attrs:{id:"_3、页面从输入-url-到页面加载显示完成的具体流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、页面从输入-url-到页面加载显示完成的具体流程"}},[t._v("#")]),t._v(" 3、页面从输入 URL 到页面加载显示完成的具体流程")]),t._v(" "),a("p",[t._v("1、浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP，向服务器发起请求（TCP 三次握手四次挥手）；"),a("br"),t._v("\n2、服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；"),a("br"),t._v("\n3、浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM）；"),a("br"),t._v("\n4、载入解析到的资源文件，渲染页面，完成。")]),t._v(" "),a("h4",{attrs:{id:"具体流程分析："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具体流程分析："}},[t._v("#")]),t._v(" 具体流程分析：")]),t._v(" "),a("p",[t._v("1、DNS域名解析：")]),t._v(" "),a("blockquote",[a("p",[t._v("（1、）解析查找浏览器DNS缓存，如果未查到执行第二步；"),a("br"),t._v("\n（2、）查找系统中hosts文件中的DNS缓存，如果未查到执行第三步；"),a("br"),t._v("\n（3、）查找本地DNS中的缓存是否存在记录，如果无执行第四步；"),a("br"),t._v("\n（4、）本地DNS向远程域服务器发起请求，获取到对应的域名和IP，返回给本地并保存对应关系，以便下次查询")])]),t._v(" "),a("p",[t._v("2、三次握手")]),t._v(" "),a("blockquote",[a("p",[t._v("（1、）第一次握手：客户端将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端进入SYN_SENT状态，等待服务端确认；"),a("br"),t._v("\n（2、）第二次握手：服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务端进入SYN_RCVD状态。"),a("br"),t._v("\n（3、）第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端，服务端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。")])]),t._v(" "),a("p",[t._v("3、HTTP请求"),a("br"),t._v("\n建立了TCP连接之后，发起一个http请求；服务器接受并处理完请求，返回 HTTP 响应")]),t._v(" "),a("p",[t._v("4、浏览器解析渲染页面")]),t._v(" "),a("p",[t._v("5、四次挥手")]),t._v(" "),a("blockquote",[a("p",[t._v("第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。"),a("br"),t._v("\n第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。"),a("br"),t._v("\n第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。"),a("br"),t._v("\n第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。")])]),t._v(" "),a("h4",{attrs:{id:"为什么需要三次握手："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要三次握手："}},[t._v("#")]),t._v(" 为什么需要三次握手：")]),t._v(" "),a("p",[t._v("三次握手的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。")]),t._v(" "),a("h4",{attrs:{id:"第三次握手失败了怎么办："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三次握手失败了怎么办："}},[t._v("#")]),t._v(" 第三次握手失败了怎么办：")]),t._v(" "),a("p",[t._v("当第三次握手失败时服务器并不会重传ack报文，而是直接发送RST报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。")]),t._v(" "),a("h4",{attrs:{id:"为什么需要四次挥手："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要四次挥手："}},[t._v("#")]),t._v(" 为什么需要四次挥手：")]),t._v(" "),a("p",[t._v("因为TCP是一个全双工协议，必须单独拆除每一条信道。4次挥手的目的是终止数据传输")])])}),[],!1,null,null,null);e.default=_.exports}}]);