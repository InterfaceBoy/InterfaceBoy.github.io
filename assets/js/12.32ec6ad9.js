(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{58:function(r,a,t){"use strict";t.r(a);var e=t(0),n=Object(e.a)({},(function(){var r=this,a=r.$createElement,t=r._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"设计模式笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式笔记"}},[r._v("#")]),r._v(" 设计模式笔记")]),r._v(" "),t("h4",{attrs:{id:"_1、构造器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、构造器"}},[r._v("#")]),r._v(" 1、构造器")]),r._v(" "),t("p",[r._v("个性与共性，变与不变的关系\n变得是个性，构造器传入的参数；不变的是传入参数的属性，他作为共性不变。\n构造器就是将传入的参数赋值给对象的封装过程，确保每一个对象都具备这些属性；而参数的值确实灵活的。")]),r._v(" "),t("h4",{attrs:{id:"_2、工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、工厂模式"}},[r._v("#")]),r._v(" 2、工厂模式")]),r._v(" "),t("p",[r._v("将创建对象封装在构造器中，对象的操作封装在工厂模式中，"),t("br"),r._v("\n构造器解决的是多个对象实例的问题，简单工厂解决的是多个类的问题。"),t("br"),r._v("\n典型的工厂模式实例：")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("function User(name , age, career, work) {\n    this.name = name\n    this.age = age\n    this.career = career \n    this.work = work\n}\n\nfunction Factory(name, age, career) {\n    let work\n    switch(career) {\n        case 'coder':\n            work =  ['写代码','写系分', '修Bug'] \n            break\n        case 'product manager':\n            work = ['订会议室', '写PRD', '催更']\n            break\n        case 'boss':\n            work = ['喝茶', '看报', '见客户']\n        case 'xxx':\n            // 其它工种的职责分配\n            ...\n            \n    return new User(name, age, career, work)\n}\n")])])]),t("p",[t("strong",[r._v("设计模式准守规则：遵守开放封闭原则")])]),r._v(" "),t("blockquote",[t("p",[r._v("对拓展开放，对修改封闭。说得更准确点，软件实体（类、模块、函数）可以扩展，但是不可修改。")])]),r._v(" "),t("p",[r._v("抽象工厂模式：\n就是将复杂的、繁琐的逻辑抽离开来，分化成个个简单的类，增强可变的扩展性。")]),r._v(" "),t("p",[r._v("抽象工厂相当于主函数，抽象产品主函数里面公共部分，具体工厂相当于操作函数，具体产品就是最终运行结果")]),r._v(" "),t("p",[r._v("抽象工厂模式的定义，是围绕一个超级工厂创建其他工厂")]),r._v(" "),t("h4",{attrs:{id:"_3、单例模式："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、单例模式："}},[r._v("#")]),r._v(" 3、单例模式：")]),r._v(" "),t("p",[r._v("保证一个类只有一个实例，并保证有一个全局访问的访问点"),t("br"),r._v("\n需要做到的第一点就是判断自己是否创建过一个实例，【object】.instance(判读实例是否存在)"),t("br"),r._v("\n简单点的解释就是：我们创建一个构造函数在用new去生成多个任意的对象，每一次出来的对象都是相同的"),t("br"),r._v("\n典型实例：vuex")]),r._v(" "),t("h4",{attrs:{id:"_4、原型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、原型模式"}},[r._v("#")]),r._v(" 4、原型模式")]),r._v(" "),t("p",[r._v("利用prototype来实现对象的创建和原型的继承"),t("br"),r._v("\n在 JavaScript 中，每个构造函数都拥有一个prototype属性，它指向构造函数的原型对象，   这个原型对象中有一个 constructor 属性指回构造函数；每个实例都有一个__proto__属性，当我们使用构造函数去创建实例 时，实例的__proto__属性就会指向构造函数的原型对象")]),r._v(" "),t("p",[r._v("原型模式更多的适合做代码编程的一种范式去运用到自己日常的工作中")]),r._v(" "),t("h4",{attrs:{id:"_5、装饰者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、装饰者模式"}},[r._v("#")]),r._v(" 5、装饰者模式")]),r._v(" "),t("p",[r._v("核心逻辑“只添加，不修改”"),t("br"),r._v("\n可扩展，在不修改之前逻辑的情况下新增业务逻辑")]),r._v(" "),t("h4",{attrs:{id:"_6、适配器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、适配器模式"}},[r._v("#")]),r._v(" 6、适配器模式")]),r._v(" "),t("p",[r._v("典型案例：axios"),t("br"),r._v("\n在 axios 的核心逻辑中，我们可以注意到实际上派发请求的是 dispatchRequest 方法。该方法内部其实主要做了两件事："),t("br"),r._v("\n1、数据转换，转换请求体/响应体，可以理解为数据层面的适配；"),t("br"),r._v("\n2、调用适配器。"),t("br"),r._v("\n封装复杂的底层逻辑，暴露出来的是简单的方法调用")]),r._v(" "),t("p",[r._v("7、")])])}),[],!1,null,null,null);a.default=n.exports}}]);