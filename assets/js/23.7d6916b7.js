(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{74:function(t,e,a){"use strict";a.r(e);var s=a(0),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"组合式api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组合式api"}},[t._v("#")]),t._v(" 组合式api")]),t._v(" "),a("p",[a("strong",[t._v("整理碎片化逻辑，将统一逻辑整理在一起，方便对逻辑进行处理")])]),t._v(" "),a("h2",{attrs:{id:"核心setup-props-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心setup-props-context"}},[t._v("#")]),t._v(" 核心setup(props,context)")]),t._v(" "),a("h3",{attrs:{id:"props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),a("p",[t._v("在setup中的props参数是接收组件传入属性")]),t._v(" "),a("p",[t._v("当props传入新的值时，setup中的值也会被更新，所以props是响应式的。"),a("br"),t._v(" "),a("strong",[t._v("setup 执行时机是在 beforeCreate 之前执行")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n  }\n}\n")])])]),a("p",[t._v("因为 props 是响应式的，你不能使用 ES6 解构，它会消除 prop 的响应性。")]),t._v(" "),a("p",[t._v("需要解构 prop，可以在 setup 函数中使用 toRefs 函数来完成")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import { toRef } from 'vue'\nsetup(props) {\n  const title = toRef(props, 'title')\n  console.log(title.value)\n}\n")])])]),a("h3",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" context")]),t._v(" "),a("p",[t._v("在setup中的context参数是接收组件传入的方法"),a("br"),t._v("\ncontext中就提供了三个属性：attrs、slot 和emit，分别对应 Vue2.x 中的 $attr属性、slot插槽 和$emit发射事件。并且这几个属性都是自动同步最新的值，所以我们每次使用拿到的都是最新值。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default {\n  setup(props, context) {\n    // Attribute (非响应式对象，等同于 $attrs)\n    console.log(context.attrs)\n\n    // 插槽 (非响应式对象，等同于 $slots)\n    console.log(context.slots)\n\n    // 触发事件 (方法，等同于 $emit)\n    console.log(context.emit)\n\n    // 暴露公共 property (函数)\n    console.log(context.expose)\n  }\n}\n")])])]),a("p",[t._v("this的使用")]),t._v(" "),a("blockquote",[a("p",[t._v("在 setup() 内部，this 不是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这使得 setup() 在和其它选项式 API 一起使用时可能会导致混淆。")])]),t._v(" "),a("h2",{attrs:{id:"响应式声明值ref、reactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式声明值ref、reactive"}},[t._v("#")]),t._v(" 响应式声明值ref、reactive")]),t._v(" "),a("p",[t._v("两者之间的区别：在setup返回的refs在模版中访问时ref是自动浅解包，而reactive是深层解包。")]),t._v(" "),a("p",[t._v("好处：可维护性明显提高，可以控制哪些变量暴露，可以跟中哪些属性被定义 （属性继承与引用透明）")]),t._v(" "),a("h3",{attrs:{id:"reactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactive"}},[t._v("#")]),t._v(" reactive")]),t._v(" "),a("p",[t._v("对引用数据类型数据进行装箱操作使得成为一个响应式对象，可以跟踪数据变化。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const count = ref(1)\nconst obj = reactive({ count:count })\n\n// ref 会被解包\nconsole.log(obj.count === count.value) // true\n\n// 它会更新 `obj.count`\ncount.value++\nconsole.log(count.value) // 2\nconsole.log(obj.count) // 2\n\n// 它也会更新 `count` ref\nobj.count++\nconsole.log(obj.count) // 3\nconsole.log(count.value) // 3\n")])])]),a("h4",{attrs:{id:"isreactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isreactive"}},[t._v("#")]),t._v(" isReactive")]),t._v(" "),a("p",[t._v("检查对象是否是由 reactive 创建的响应式代理。")]),t._v(" "),a("h4",{attrs:{id:"readonly"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#readonly"}},[t._v("#")]),t._v(" readonly")]),t._v(" "),a("p",[t._v("接受一个对象 (响应式或纯对象) 或 ref 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatchEffect(() => {\n  // 用于响应性追踪\n  console.log(copy.count)\n})\n\n// 变更 original 会触发依赖于副本的侦听器\noriginal.count++\n\n// 变更副本将失败并导致警告\n")])])]),a("h4",{attrs:{id:"shallowreactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shallowreactive"}},[t._v("#")]),t._v(" shallowReactive")]),t._v(" "),a("p",[t._v("创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (暴露原始值)。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const state = shallowReactive({\n  foo: 1,\n  nested: {\n    bar: 2\n  }\n})\n\n// 改变 state 本身的性质是响应式的\nstate.foo++\n// ...但是不转换嵌套对象\nisReactive(state.nested) // false\nstate.nested.bar++ // 非响应式\n")])])]),a("h3",{attrs:{id:"ref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[t._v("#")]),t._v(" ref")]),t._v(" "),a("p",[t._v("对基本数据类型数据进行装箱操作使得成为一个响应式对象，可以跟踪数据变化。"),a("br"),t._v("\n接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。")]),t._v(" "),a("h4",{attrs:{id:"toref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#toref"}},[t._v("#")]),t._v(" toRef")]),t._v(" "),a("p",[t._v("主要用于接收props参数时使用，\n因为即使源 property 不存在，toRef 也会返回一个可用的 ref。这使得它在使用可选 prop 时特别有用，可选 prop 并不会被 toRefs 处理。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default {\n  setup(props) {\n    useSomeFeature(toRef(props, 'foo'))\n  }\n}\n")])])]),a("h4",{attrs:{id:"torefs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#torefs"}},[t._v("#")]),t._v(" toRefs")]),t._v(" "),a("p",[t._v("将响应式对象转化为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。\n主要用于reactive解构使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const state = reactive({\n    foo: 1,\n    bar: 2\n  });\n\n  const stateAsRefs = toRefs(state);\n\n  // ref 和原始 property 已经“链接”起来了\n  state.foo++;\n  console.log(stateAsRefs.foo.value); // 2\n\n  stateAsRefs.foo.value++;\n  console.log(state.foo); // 3\n  //  const { foo, bar } = stateAsRefs;\n  const { foo, bar } = state;\n  console.log(foo.value, bar.value);\n")])])]),a("h4",{attrs:{id:"isref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isref"}},[t._v("#")]),t._v(" isRef")]),t._v(" "),a("p",[t._v("检查值是否为一个 ref 对象。")]),t._v(" "),a("h2",{attrs:{id:"动态监听（computed，watch）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态监听（computed，watch）"}},[t._v("#")]),t._v(" 动态监听（computed，watch）")]),t._v(" "),a("h3",{attrs:{id:"computed计算属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed计算属性"}},[t._v("#")]),t._v(" computed计算属性")]),t._v(" "),a("p",[t._v("1、接受一个getter函数，并根据getter的返回值返回一个不可变的响应式ref对象。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  const count = ref(1)\n  const plusOne = computed(() => count.value + 1)\n\n  console.log(plusOne.value) // 2\n\n  plusOne.value++ // 错误 :返回的是一个不可变的响应式ref对象\n")])])]),a("p",[t._v("2、或者，接受一个具有 get 和 set 函数的对象，用来创建可写的 ref 对象。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  const count = ref(1);\n  const plusOne = computed({\n    get: () => count.value + 1,\n    set: val => {\n      count.value = val - 1;\n    }\n  });\n\n  console.log(count.value); // 1 只是单纯的获取ref中count的值，未触发computed\n  console.log(plusOne.value); // 2 获取computed属性值，触发get函数\n  count.value = 2;\n  console.log(plusOne.value); // 3 获取computed属性值，触发get函数，count.value=2,\n  plusOne.value = 4;\n  console.log(count.value); // 3 因为plusOne传入值，触发set函数，4-1=3。\n  console.log(plusOne.value); // 4 当前count.value=3,获取计算属性触发get 3+1=4\n")])])]),a("p",[t._v("3、在reactive中使用 computed")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('const date = reactive({ \n  dates:new Date(),\n  timeData:computed(()=>{ \n    return date.dates\n  }), \n  yearData:""\n})\nconst {timeData, yearData} = toRefs(date)\n\nreturn {\n  timeData, yearData\n}\n')])])]),a("h3",{attrs:{id:"watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")])])}),[],!1,null,null,null);e.default=n.exports}}]);