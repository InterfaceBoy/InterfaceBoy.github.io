(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{71:function(t,e,r){"use strict";r.r(e);var v=r(0),s=Object(v.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"vue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),r("p",[t._v("Vue 是一套用于构建用户界面的渐进式 MVVM 框架。"),r("br"),t._v(" "),r("strong",[t._v("特点：")]),t._v(" 声明式渲染、组件化系统、客户端路由、大规模状态管理、构建工具、数据持久化、跨平台支持")]),t._v(" "),r("h2",{attrs:{id:"基本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),r("h3",{attrs:{id:"_1、什么是-mvvm-框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是-mvvm-框架"}},[t._v("#")]),t._v(" 1、什么是 MVVM 框架")]),t._v(" "),r("p",[r("strong",[t._v("Model-View-ViewModel 模式")])]),t._v(" "),r("h4",{attrs:{id:"model-层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#model-层"}},[t._v("#")]),t._v(" Model 层")]),t._v(" "),r("p",[t._v("对应数据层的域模型，主要做域模型的同步。通过 Ajax 等 API 完成客户端和服务端的 model 数据同步。")]),t._v(" "),r("h4",{attrs:{id:"view-层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#view-层"}},[t._v("#")]),t._v(" View 层")]),t._v(" "),r("p",[t._v("作为视图模版存在，在 MVVM 的中属于一个动态模版，主要负责定义结构、页面布局和 ViewModel 层数据和状态的展示，还包括事件的声明、数据绑定的声明、指令的声明。")]),t._v(" "),r("h4",{attrs:{id:"viewmodel-层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#viewmodel-层"}},[t._v("#")]),t._v(" ViewModel 层")]),t._v(" "),r("p",[t._v("为 View 层提供数据，并对 View 层声明的事件、数据绑定、指令进行负责，处理 View 层具体业务逻辑，绑定监听属性，获取 Model 层数据,进行实时数据更新，实现 Model-View 数据双向绑定。")]),t._v(" "),r("img",{attrs:{src:t.$withBase("/mvvm.jpg"),alt:"foo"}}),t._v(" "),r("p",[t._v("vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\nMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果")]),t._v(" "),r("img",{attrs:{src:t.$withBase("/mvvm1.png"),alt:"foo"}}),t._v(" "),r("h3",{attrs:{id:"_2、生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、生命周期"}},[t._v("#")]),t._v(" 2、生命周期")]),t._v(" "),r("p",[r("strong",[t._v("创建——挂载——渲染——销毁")])]),t._v(" "),r("img",{attrs:{src:t.$withBase("/smzq.png"),alt:"foo"}}),t._v(" "),r("p",[r("strong",[t._v("各生命周期作用")]),t._v(" "),r("img",{attrs:{src:t.$withBase("/zq.png"),alt:"foo"}})]),t._v(" "),r("h3",{attrs:{id:"_3、单向数据流和组件通讯"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、单向数据流和组件通讯"}},[t._v("#")]),t._v(" 3、单向数据流和组件通讯")]),t._v(" "),r("h4",{attrs:{id:"单向数据流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流"}},[t._v("#")]),t._v(" 单向数据流")]),t._v(" "),r("blockquote",[r("p",[t._v("所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。"),r("br"),t._v("\n额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。")])]),t._v(" "),r("h4",{attrs:{id:"常见的组件通讯方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见的组件通讯方式"}},[t._v("#")]),t._v(" 常见的组件通讯方式")]),t._v(" "),r("p",[r("strong",[t._v("1、props / $emit")])]),t._v(" "),r("p",[t._v("通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。")]),t._v(" "),r("p",[r("strong",[t._v("2、$children / $parent")])]),t._v(" "),r("p",[t._v("通过$parent和$children就可以访问组件的所有方法和data，$parent拿到的是一个对象， $children拿到的是一个数组")]),t._v(" "),r("p",[r("strong",[t._v("3、provide/ inject")])]),t._v(" "),r("p",[t._v("父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。")]),t._v(" "),r("blockquote",[r("p",[t._v("注意: 这里不论子组件嵌套有多深, 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中回去数据,只能进行自上而下的单向流传递。")])]),t._v(" "),r("p",[r("strong",[t._v("4、$attrs/$listeners")])]),t._v(" "),r("p",[t._v("$attrs用于获取父作用域中的所有属性，$listeners用于监听父作用域中的所有事件。可以进行跨级的组件通信")]),t._v(" "),r("p",[r("strong",[t._v("5、EventBus")])]),t._v(" "),r("p",[t._v("通过EventBus进行信息的发布与订阅，eventBus 又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。")]),t._v(" "),r("p",[r("strong",[t._v("6、Vuex")])]),t._v(" "),r("p",[t._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，主要解决多视图依赖同一状态或多视图更改同一状态的问题。")]),t._v(" "),r("p",[t._v("Vuex各个模块")]),t._v(" "),r("blockquote",[r("p",[t._v("state：用于数据的存储，是store中的唯一数据源"),r("br"),t._v("\ngetters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算"),r("br"),t._v("\nmutations：类似函数，改变state数据的唯一途径，且不能用于处理异步事件"),r("br"),t._v("\nactions：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作"),r("br"),t._v("\nmodules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护")])]),t._v(" "),r("p",[r("strong",[t._v("7、ref / refs")])]),t._v(" "),r("p",[t._v("ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据")]),t._v(" "),r("p",[r("strong",[t._v("8、localStorage / sessionStorage")])]),t._v(" "),r("p",[t._v("传统解决方案")])])}),[],!1,null,null,null);e.default=s.exports}}]);