(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{57:function(e,s,a){"use strict";a.r(s);var t=a(0),r=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"页面传输：postmessage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页面传输：postmessage"}},[e._v("#")]),e._v(" 页面传输：postMessage")]),e._v(" "),a("p",[e._v("postMessage主要用于解决两个不同域页面之间的通信")]),e._v(" "),a("h4",{attrs:{id:"mdn官方"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mdn官方"}},[e._v("#")]),e._v(" MDN官方")]),e._v(" "),a("blockquote",[a("p",[e._v("window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。")])]),e._v(" "),a("p",[a("strong",[e._v("发送消息窗口通过消息事件对象暴露的方式将数据发送给接收窗口")])]),e._v(" "),a("h4",{attrs:{id:"发送语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发送语法"}},[e._v("#")]),e._v(" 发送语法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("otherWindow.postMessage(message, targetOrigin, [transfer]);\n")])])]),a("p",[e._v("1、otherWindow：其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象等。"),a("br"),e._v("\n2、message：将要发送到其他 window 的数据，它将会被结构化克隆算法序列化。"),a("br"),e._v('\n3、targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串 "*"（表示无限制）或者一个 URI。'),a("br"),e._v("\n4、transfer（可选）：是一串和 message 同时传递的 Transferable 对象(Transferable 接口代表一个能在不同可执行上下文之间，列如主线程和 Worker 之间，相互传递的对象。)。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。")]),e._v(" "),a("h4",{attrs:{id:"监听即接收语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监听即接收语法"}},[e._v("#")]),e._v(" 监听即接收语法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('window.addEventListener("message",  (event)=>{console.log(event.data)}, false);\n')])])]),a("p",[e._v("重点介绍event对象的四个属性"),a("br"),e._v("\n1、data :   指的是从其他窗口发送过来的消息对象;"),a("br"),e._v("\n2、type:   指的是发送消息的类型;"),a("br"),e._v("\n3、source:   指的是发送消息的窗口对象;"),a("br"),e._v("\n4、origin: 指的是发送消息的窗口的源")]),e._v(" "),a("h4",{attrs:{id:"安全问题（防止跨站脚本的恶意攻击）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全问题（防止跨站脚本的恶意攻击）"}},[e._v("#")]),e._v(" 安全问题（防止跨站脚本的恶意攻击）")]),e._v(" "),a("p",[e._v("1、在接收数据窗口需要始终使用origin和source属性验证发送窗口的身份"),a("br"),e._v("\n2、使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是*。")]),e._v(" "),a("h4",{attrs:{id:"代码演示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码演示"}},[e._v("#")]),e._v(" 代码演示")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// iframe传输端\n  const iframe = this.$refs.iframe.contentWindow;\n      iframe.postMessage(data, "*");\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 界面接收端\nwindow.addEventListener("message", this.onMessage);\nfunction  onMessage(res) {\n      console.log(res);\n       retrun ;\n    },\n')])])])])}),[],!1,null,null,null);s.default=r.exports}}]);