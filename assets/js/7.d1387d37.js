(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{55:function(e,t,n){"use strict";n.r(t);var a=n(0),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"字符串操作技巧"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#字符串操作技巧"}},[e._v("#")]),e._v(" 字符串操作技巧")]),e._v(" "),n("h3",{attrs:{id:"_1、判断字符串是否包含某个字符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、判断字符串是否包含某个字符"}},[e._v("#")]),e._v(" 1、判断字符串是否包含某个字符")]),e._v(" "),n("h4",{attrs:{id:"indexof"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#indexof"}},[e._v("#")]),e._v(" indexOf")]),e._v(" "),n("p",[n("strong",[e._v("indexOf()")]),e._v("：查找某个字符，有则返回第一次匹配到的位置，否则返回-1"),n("br"),e._v(" "),n("strong",[e._v("indexOf（要查的元素，开始查询的下标位置）")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let str = "123456";\nconsole.log(str.indexOf("1"));   // 输出结果：0\nconsole.log(str.indexOf("7"));   // 输出结果：-1\nconsole.log(str.indexOf("6",6));   // 输出结果：7\n')])])]),n("p",[e._v("注：该方法同样适用于数组操作")]),e._v(" "),n("h4",{attrs:{id:"includes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#includes"}},[e._v("#")]),e._v(" includes")]),e._v(" "),n("p",[n("strong",[e._v("includes()")]),e._v("：该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false"),n("br"),e._v(" "),n("strong",[e._v("includes（要查的元素，开始查询的下标位置）")])]),e._v(" "),n("p",[e._v("注：使用 includes()比较字符串和字符时是区分大小写。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let str = '123456';\n\nstr.includes('1')  // 输出结果：true\nstr.includes('7')  // 输出结果：false\nstr.includes('6', 6)  // 输出结果：false\n")])])]),n("p",[e._v("注：该方法同样适用于数组操作")]),e._v(" "),n("h3",{attrs:{id:"_2、字符串截取"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、字符串截取"}},[e._v("#")]),e._v(" 2、字符串截取")]),e._v(" "),n("h4",{attrs:{id:"slice"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#slice"}},[e._v("#")]),e._v(" slice")]),e._v(" "),n("p",[n("strong",[e._v("slice()")]),e._v(" 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分，不改变原字符串。"),n("br"),e._v(" "),n("strong",[e._v("slice(开始位置，结束位置)")]),n("br"),e._v("\n结束位置不填写值时表示到字符串结尾处，负数则代表从结尾开始")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let str = "abcdefg";\nstr.slice(1,6);   // 输出结果："bcdef" \nstr.slice(1);     // 输出结果："bcdefg" \nstr.slice();      // 输出结果："abcdefg" \nstr.slice(-2);    // 输出结果："fg"\nstr.slice(6, 1);  // 输出结果："" \n')])])]),n("p",[e._v("注：该方法同样适用于数组操作,数组使用时是浅拷贝")]),e._v(" "),n("h4",{attrs:{id:"substring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#substring"}},[e._v("#")]),e._v(" substring")]),e._v(" "),n("p",[n("strong",[e._v("substring()")]),e._v(" 用于提取字符串中介于两个指定下标之间的字符")]),e._v(" "),n("p",[n("strong",[e._v("str.substring(a, b)")]),n("br"),e._v("\na:需要截取的第一个字符的索引，该索引位置的字符作为返回的字符串的首字母。"),n("br"),e._v("\nb:(可选)一个 0 到字符串长度之间的整数，以该数字为索引的字符不包含在截取的字符串内。")]),e._v(" "),n("blockquote",[n("p",[e._v("substring 提取从 a 到 b（不包括）之间的字符。特别地："),n("br"),e._v("\n如果 a 等于 b，substring 返回一个空字符串。"),n("br"),e._v("\n如果省略 b，substring 提取字符一直到字符串末尾。"),n("br"),e._v("\n如果任一参数小于 0 或为 NaN，则被当作 0。\n如果任一参数大于 stringName.length，则被当作 stringName.length。\n如果 a 大于 b，则 substring 的执行效果就像两个参数调换了一样。见下面的例子。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var anyString = "Mozilla";\n\n// 输出 "Moz"\nconsole.log(anyString.substring(0,3));\nconsole.log(anyString.substring(3,0));\nconsole.log(anyString.substring(3,-3));\nconsole.log(anyString.substring(3,NaN));\nconsole.log(anyString.substring(-2,3));\nconsole.log(anyString.substring(NaN,3));\n\n// 输出 "lla"\nconsole.log(anyString.substring(4,7));\nconsole.log(anyString.substring(7,4));\n\n// 输出 ""\nconsole.log(anyString.substring(4,4));\n\n// 输出 "Mozill"\nconsole.log(anyString.substring(0,6));\n\n// 输出 "Mozilla"\nconsole.log(anyString.substring(0,7));\nconsole.log(anyString.substring(0,10));\n')])])]),n("h3",{attrs:{id:"_3、字符串替换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、字符串替换"}},[e._v("#")]),e._v(" 3、字符串替换")]),e._v(" "),n("h4",{attrs:{id:"replace"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#replace"}},[e._v("#")]),e._v(" replace()")]),e._v(" "),n("p",[e._v("替换指定字符串，并返回一个新的字符串，不改变原字符串")]),e._v(" "),n("p",[n("strong",[e._v("string.replace(searchvalue, newvalue)")])]),e._v(" "),n("p",[e._v("searchvalue：一个RegExp 对象或者其字面量，要替换的字符串；"),n("br"),e._v("\nnewvalue：用于替换掉第一个参数在原字符串中的匹配部分的字符串，该参数可以为一个function函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let str = "abcdef";\nstr.replace("c", "z") // 输出结果：abzdef\n')])])]),n("h3",{attrs:{id:"_4、字符串转数字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4、字符串转数字"}},[e._v("#")]),e._v(" 4、字符串转数字")]),e._v(" "),n("h4",{attrs:{id:"parseint"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#parseint"}},[e._v("#")]),e._v(" parseInt()")]),e._v(" "),n("p",[e._v("解析一个字符串并返回指定基数的十进制整数")]),e._v(" "),n("p",[n("strong",[e._v("parseInt(string, radix)")])]),e._v(" "),n("p",[e._v("string：字符串，既被解析的值"),n("br"),e._v("\nradix ：可选从 2 到 36，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！\n由于不是所有的浏览器都是默认采用的10进制方案进行的，因此，在使用 parseInt 时，一定要指定一个 radix。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('parseInt("50",10);\t\t\t  // 输出结果：50\n')])])]),n("h4",{attrs:{id:"parsefloat"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#parsefloat"}},[e._v("#")]),e._v(" parseFloat()")]),e._v(" "),n("p",[e._v("函数解析一个参数（必要时先转换为字符串）并返回一个浮点数。")]),e._v(" "),n("p",[e._v("给定值被解析成浮点数。如果给定值不能被转换成数值，则会返回 NaN。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('parseFloat("10.01")      // 输出结果：10.01\n')])])]),n("h2",{attrs:{id:"数组操作技巧"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组操作技巧"}},[e._v("#")]),e._v(" 数组操作技巧")]),e._v(" "),n("h3",{attrs:{id:"_1、求交集"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、求交集"}},[e._v("#")]),e._v(" 1、求交集")]),e._v(" "),n("p",[e._v("利用filter测试数组中的每一个元素，在使用includes来判断是否有相同元素，如果有相同的元素则将\n返回在一个新的数组中"),n("br"),e._v("\n实例："),n("br"),e._v(" "),n("code",[e._v("let a=[1,2,3,4,5,6],b=[4,5,6,7,8,9];")]),n("br"),e._v(" "),n("strong",[e._v("方法1")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" let intersection = a.filter(v => b.includes(v)) // [4,5,6]\n")])])]),n("p",[n("strong",[e._v("方法2")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  let aSet = new Set(a)\n  let bSet = new Set(b)\n  let intersection = Array.from(new Set(a.filter(v => bSet.has(v))))  \n")])])]),n("h3",{attrs:{id:"_2、求并集"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、求并集"}},[e._v("#")]),e._v(" 2、求并集")]),e._v(" "),n("p",[n("strong",[e._v("方法1")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  let union = a.concat(b.filter(v => !a.includes(v))) // [1,2,3,4,5,6,7,8,9]\n")])])]),n("p",[n("strong",[e._v("方法2")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" let aSet = new Set(a)\n let bSet = new Set(b)\n let union = Array.from(new Set(a.concat(b)))\n")])])]),n("h3",{attrs:{id:"_3、求差集"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、求差集"}},[e._v("#")]),e._v(" 3、求差集")]),e._v(" "),n("p",[n("strong",[e._v("方法1")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v)) // [1,2,3,7,8,9]\n")])])]),n("p",[n("strong",[e._v("方法2")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let aSet = new Set(a)\nlet bSet = new Set(b)\nlet difference = Array.from(new Set(a.concat(b).filter(v => !aSet.has(v) || !bSet.has(v))))  \n")])])]),n("h2",{attrs:{id:"数据类型转换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据类型转换"}},[e._v("#")]),e._v(" 数据类型转换")]),e._v(" "),n("p",[e._v("数据原型")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const tree = [\n      {\n        name: "一号",\n        age: 100,\n        children: [\n          {\n            name: "一号大儿子",\n            age: 75,\n            children: [\n              {\n                name: "一号大孙子",\n                age: 50,\n                children: [{ name: "一号大重孙子", age: 25, children: [] }],\n              },\n              { name: "一号二孙子", age: 49, children: [] },\n            ],\n          },\n          {\n            name: "一号二儿子",\n            age: 65,\n            children: [\n              { name: "一号二儿子的大儿子", age: 38, children: [] },\n              { name: "一号二儿子的二儿子", age: 35, children: [] },\n            ],\n          },\n        ],\n      },\n    ],\n')])])]),n("h3",{attrs:{id:"_1、tree树形转list数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、tree树形转list数组"}},[e._v("#")]),e._v(" 1、tree树形转list数组")]),e._v(" "),n("p",[e._v("算法的实现主要分为两种：递归和非递归")]),e._v(" "),n("h4",{attrs:{id:"非递归-队列方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#非递归-队列方式"}},[e._v("#")]),e._v(" 非递归 (队列方式)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" treeConversionListArray(tree) {\n      const list = [];\n      const queue = [...tree];\n      while (queue.length) {\n        // 方法一：沿着树的宽度遍历节点。采用队列来辅助完成广度遍历。\n        const node = queue.shift();\n        // 方法二：沿着树的深度遍历。采用栈来辅助完成深度遍历。\n        const node = queue.pop();\n        console.log(node);\n        const nodeChildren = node.children;\n        if (nodeChildren) {\n          queue.push(...nodeChildren);\n        }\n        const { children, ...other } = node;\n        list.push(other);\n      }\n      console.log(list);\n      return list;\n    },\n")])])]),n("p",[n("strong",[e._v("深度优先遍历（DFS）：至上而下的遍历")]),e._v("\n该方法是以纵向的维度对dom树进行遍历，从一个dom节点开始，一直遍历其子节点，直到它的所有子节点都被遍历完毕之后在遍历它的兄弟节点\n"),n("img",{attrs:{src:e.$withBase("/DFS.png"),alt:"foo"}})]),e._v(" "),n("p",[n("strong",[e._v("广度优先遍历（BFT）：逐层深入的遍历")]),e._v("\n该方法是以横向的维度对dom树进行遍历，从该节点的第一个子节点开始，遍历其所有的兄弟节点，再遍历第一个节点的子节点，完成该遍历之后，暂时不深入，开始遍历其兄弟节点的子节点。\n"),n("img",{attrs:{src:e.$withBase("/BFT.png"),alt:"foo"}})]),e._v(" "),n("h4",{attrs:{id:"递归方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#递归方式"}},[e._v("#")]),e._v(" 递归方式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" treeConversionListArray(tree) {\n     const dataList = tree.map((i) => {\n        return deepFirstSearch(i, []);\n      });\n      function deepFirstSearch(node, nodeList) {\n        if (node) {\n          nodeList.push(node);\n          const children = node.children;\n          for (let i = 0; i < children.length; i++)\n            // 每次递归的时候将 需要遍历的节点 和 节点所存储的数组传下去\n            deepFirstSearch(children[i], nodeList);\n        }\n        return nodeList;\n  }\n")])])]),n("p",[e._v("结果")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('{name: "一号", age: 100},\n{name: "一号大儿子", age: 75}\n{name: "一号二儿子", age: 65} \n{name: "一号二孙子", age: 49}\n{name: "一号二儿子的大儿子", age: 38}\n{name: "一号二儿子的二儿子", age: 35}\n{name: "一号大孙子", age: 50}\n{name: "一号大重孙子", age: 25}\n')])])]),n("h3",{attrs:{id:"_2、list数组转tree树形"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、list数组转tree树形"}},[e._v("#")]),e._v(" 2、list数组转tree树形")]),e._v(" "),n("h4",{attrs:{id:"方法一：双层循环"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法一：双层循环"}},[e._v("#")]),e._v(" 方法一：双层循环")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" listConversionTree(list) { \n      list.forEach((child) => {\n        const pid = child.pid;\n        if (pid) {\n          list.forEach((parent) => {\n            if (parent.id === pid) {\n              parent.children = parent.children || [];\n              parent.children.push(child);\n            }\n          });\n        }\n      });\n      return list.filter((n) => !n.pid);\n }\n")])])]),n("h4",{attrs:{id:"方法二：递归组装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法二：递归组装"}},[e._v("#")]),e._v(" 方法二：递归组装")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("listConversionTree(list) { \n      const tree = [];\n      for (const node of list) {\n        // 如果没有pid就可以认为是根节点\n        if (!node.pid) {\n          let p = { ...node };\n          p.children = getChildren(p.id, list);\n          tree.push(p);\n        }\n      }\n      function getChildren(id, list) {\n        const children = [];\n        for (const node of list) {\n          if (node.pid === id) {\n            children.push(node);\n          }\n        }\n\n        for (const node of children) {\n          const children = getChildren(node.id, list);\n          if (children.length) {\n            node.children = children;\n          }\n        }\n\n        return children;\n      }\n      console.log(tree);\n      return tree;\n }\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);