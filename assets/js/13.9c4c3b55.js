(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{64:function(t,e,n){"use strict";n.r(e);var a=n(0),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"es6-语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6-语法"}},[t._v("#")]),t._v(" es6 语法")]),t._v(" "),n("h2",{attrs:{id:"_1、判断-javascript-数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、判断-javascript-数据类型"}},[t._v("#")]),t._v(" 1、判断 JavaScript 数据类型")]),t._v(" "),n("blockquote",[n("p",[t._v("1、typeof()函数")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(' console.log(\n        typeof 1, //number\n        typeof "1", //string\n        typeof true, //boolean\n        typeof undefined, //undefined\n        typeof null // object\n      );\n')])])]),n("p",[n("strong",[t._v("因为 typeof null 返回的是 object，但是 null 这个是 string 类型的，没法用来区分引用数据类型，所以 typeof 一般都是用于判断值类型数据（number，string，boolean，undefined）")])]),t._v(" "),n("blockquote",[n("p",[t._v("2、instanceof 方法")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(' let obj = {};\n      obj instanceof Object; //true\n\n      let arr = [];\n      arr instanceof Array; //true\n\n      let now = new Date();\n      now instanceof Date; //true\n\n      let func = function() {};\n      func instanceof Function; //true\n\n      let str = "string";\n      let PDstr = str instanceof String; //false\n      console.log(PDstr);\n')])])]),n("p",[n("strong",[t._v("因为上面例子中 PDstr 返回的是 false，但是这个实例又是 string 类型的，所以无法对值类型进行判断，instanceof 一般用来判断一个变量是否是某个对象的实例，所以对于引用类型我们使用 instanceof 来进行类型判断。")])]),t._v(" "),n("blockquote",[n("p",[t._v("3、Object.prototype.toString.call()")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let num1 = 1;\n      let num2 = new Number(1);\n      let numB = Object.prototype.toString.call(num1) == "[object Number]"; //true\n      Object.prototype.toString.call(num2) == "[object Number]"; //true\n      console.log(numB);\n      let att = [];\n      Object.prototype.toString.call(att) == "[object Array]"; //true\n\n      let attf = function() {};\n      let attfFn = Object.prototype.toString.call(attf) == "[object Function]"; //true\n      console.log(attfFn);\n\n      function A() {}\n      let a = new A();\n      Object.prototype.toString.call(a) == "[object Object]"; //true\n')])])]),n("p",[n("strong",[t._v("在 javascript 高级程序设计中提供了另一种方法，可以通用的来判断原始数据类型和引用数据类型")])]),t._v(" "),n("blockquote",[n("p",[t._v("4、constructor")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(' console.log("constructor", [].constructor === Array);\n      console.log({}.constructor === Object);\n      console.log("string".constructor === String);\n      console.log((123).constructor === Number);\n      console.log(true.constructor === Boolean);\n')])])]),n("p",[n("strong",[t._v("属性返回对创建此对象的数组函数的引用,就是返回对象相对应的构造函数。原因：constructor 是 prototype 对象上的属性，指向构造函数。")])]),t._v(" "),n("h2",{attrs:{id:"_2、隐式类型转换以及转换原则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、隐式类型转换以及转换原则"}},[t._v("#")]),t._v(" 2、隐式类型转换以及转换原则")]),t._v(" "),n("p",[t._v("最常见的隐式类型转换主要是 boolead 转换")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('  let test;\n      test = null;\n      if (!test) {\n        console.log("非空字符串会转换成true，空字符串会转换成false", !test);\n      }\n      test = "";\n      if (!test) {\n        console.log("\'\'和null都是空字符串", !test);\n      }\n      test = 0;\n      if (!test) {\n        console.log("非0会转换成true，0会转换成false", !test);\n      }\n      test = {};\n      if (test) {\n        console.log("任何对象都会转成true", !test);\n      }\n')])])]),n("blockquote",[n("p",[t._v("1、String，非空字符串会转换成 true，空字符串会转换成 false"),n("br"),t._v("\n2、Number, 非 0 会转换成 true，0 会转换成 false"),n("br"),t._v("\n3、Object，任何对象都会转成 true")])]),t._v(" "),n("h2",{attrs:{id:"_3、instanceof-解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、instanceof-解析"}},[t._v("#")]),t._v(" 3、instanceof 解析")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function instance_of(L, R) { // L即stu ；  R即Person\n\n  const O = R.prototype; // O为Person.prototype\n\n   L = L.__proto__;   //L为stu._proto_，现在指向的是per实例对象\n\n   while (true) {   // 执行循环\n\n      if (L === null)   //不通过\n\n          return false;\n\n      if (O === L)    //判断：   Person.prototype === stu._proto_ ？\n\n           return true;   //此时，stu._proto_ 指向per实例对象，并不满足\n\n       L = L.__proto__;  //令L=  stu._proto_._proto_，执行循环\n\n  }                      //stu._proto_ ._proto_，看图示知：\n\n}\n")])])]),n("h2",{attrs:{id:"_4、逻辑运算符（-和-）-的使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4、逻辑运算符（-和-）-的使用"}},[t._v("#")]),t._v(" 4、逻辑运算符（|| 和 &&） 的使用")]),t._v(" "),n("p",[n("strong",[t._v("定义：")]),t._v(" &&是“与”的意思，||是“或者”的意思")]),t._v(" "),n("p",[n("strong",[t._v("使用方式：")]),t._v(" a && b：a 和 b 同时为 true 才返回 true， 否则返回 false；a || b：a 或 b 任意一个为 true 就返回 true ， 否则返回 false")]),t._v(" "),n("p",[n("strong",[t._v("运算方式：")]),t._v(" 都表示运算，但是&&运算符第一个表达式不成立的话，后面的表达式不运算，直接返回。而&对所有表达式都得判断。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('  let judgingType = screeningType.some(item => {\n        return (\n          (data.indicator === "" && item.value !== "") ||\n          (data.indicator === undefined && item.value !== "")\n        );\n      });\n')])])]),n("h2",{attrs:{id:"_5、强大javascript运算符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5、强大javascript运算符"}},[t._v("#")]),t._v(" 5、强大JavaScript运算符")]),t._v(" "),n("h3",{attrs:{id:"_1、多重三元运算（？：）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、多重三元运算（？：）"}},[t._v("#")]),t._v(" 1、多重三元运算（？：）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const size = val =>\n  Array.isArray(val)\n    ? val.length\n    : val && typeof val === 'object'\n    ? val.size || val.length || Object.keys(val).length\n    : typeof val === 'string'\n    ? new Blob([val]).size\n    : 0;\n\nsize([1, 2, 3, 4, 5]); // 5\nsize('yuan'); // 4\nsize({ one: 1, two: 2, three: 3 }); // 3\n")])])]),n("p",[n("strong",[t._v("这个的实现非常巧妙，利用 Blob 类文件对象的特性，获取对象的长度。")])]),t._v(" "),n("h3",{attrs:{id:"_2、-非空运算符（-）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、-非空运算符（-）"}},[t._v("#")]),t._v(" 2、 非空运算符（??）")]),t._v(" "),n("p",[t._v("?? 运算符被称为非空运算符。"),n("br"),t._v("\n如果第一个参数不是 null/undefined，将返回第一个参数，否则返回第二个参数")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("null ?? 5\n// 5\n3 ?? 4\n// 3\n")])])]),n("p",[n("strong",[t._v("注意这里的假值只是 null/undefined")])]),t._v(" "),n("h3",{attrs:{id:"_3、逻辑空赋值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、逻辑空赋值"}},[t._v("#")]),t._v(" 3、逻辑空赋值 (??=)")]),t._v(" "),n("p",[t._v("逻辑空赋值运算符 (x ??= y) 仅在 x 是 null 或 undefined时对其赋值。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const a = { duration: 50 };\n\na.duration ??= 10;\nconsole.log(a.duration);\n// expected output: 50\n\na.speed ??= 25;\nconsole.log(a.speed);\n// expected output: 25\n\n")])])]),n("p",[t._v("??= 可用来初始化缺失的属性")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const pages = [\n  {\n    title:\'主要场景\',\n    path:\'/\'\n  },\n  {\n    path:\'/a\'\n  },\n  {\n    path:\'/b\'\n  },\n]\n\nfor (const page of pages){\n    page.title ??= \'默认标题\'\n}\n\nconsole.table(pages)\n//(index)   title          path\n//0        "主要场景"       "/"\n//1        "默认标题"       "/a"\n//2        "默认标题"       "/b"\n')])])]),n("p",[t._v("空赋值的短路用法"),n("br"),t._v(" "),n("strong",[t._v("空值合并运算符从左至右求值")])]),t._v(" "),n("blockquote",[n("p",[t._v("(结果非 null 或 undefined 的表达式) ?? expr 被短路求值为左侧表达式，当左侧证明为既非 null 也非 undefined.")])]),t._v(" "),n("blockquote",[n("p",[t._v("语法短路意味着 expr 部分尚未被求值，因此任何与其求值产生的相关副作用都不会生效（例如，如果 expr 是一个函数调用，则该调用将不会发生）。")])]),t._v(" "),n("p",[t._v("逻辑空赋值的语法短路也意味着 x ??= y 等价于：")]),t._v(" "),n("blockquote",[n("p",[t._v("x ?? (x = y);")])]),t._v(" "),n("p",[t._v("而不等价于如下的表达式，因为其一定会发生赋值：")]),t._v(" "),n("blockquote",[n("p",[t._v("x = x ?? y;")])]),t._v(" "),n("p",[t._v("在使用??=时，这里的假值只是 null/undefined")]),t._v(" "),n("p",[n("strong",[t._v("逻辑运算||=")])]),t._v(" "),n("p",[t._v("在||=中判断的假值可以是''/null/undefined/0")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const a = { duration: 50, title: '' };\n\na.duration ||= 10;\nconsole.log(a.duration);\n// expected output: 50\n\na.title ||= 'title is empty.';\nconsole.log(a.title);\n// expected output: \"title is empty\"\n")])])]),n("p",[n("strong",[t._v("赋值表达式")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("a ||= b\n//等价于\na = a || (a = b)\n\na &&= b\n//等价于\na = a && (a = b)\n\na ??= b\n//等价于\na = a ?? (a = b)\n")])])]),n("p",[n("strong",[t._v("注意：")])]),t._v(" "),n("blockquote",[n("p",[t._v("a ||= b：当a值不存在时，将b变量赋值给a"),n("br"),t._v("\na &&= b：当a值存在时，将b变量赋值给a"),n("br"),t._v("\na ??= b：当a值为null或者undefined时，将b变量赋值给a")])]),t._v(" "),n("h3",{attrs:{id:"_4、可选链操作符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4、可选链操作符"}},[t._v("#")]),t._v(" 4、可选链操作符(?.)")]),t._v(" "),n("p",[t._v("通过使用 ?. 操作符取代 . 操作符，JavaScript 会在尝试访问 obj.first.second 之前，先隐式地检查并确定 obj.first 既不是 null 也不是 undefined。如果obj.first 是 null 或者 undefined，表达式将会短路计算直接返回 undefined。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const adventurer = {\n  name: 'Alice',\n  cat: {\n    name: 'Dinah'\n  }\n};\n\nconst dogName = adventurer.cat?.name;\nconsole.log(dogName);\n// expected output: Dinah\n\nconsole.log(adventurer.cat?.age);\n// expected output: undefined\n")])])]),n("p",[t._v("如果在对象的每一层都需要判断")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("adventurer?.set?.age\n")])])]),n("p",[n("strong",[t._v("在Map中使用可选链操作符")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let myMap = new Map();\nmyMap.set("foo", {name: "baz", desc: "inga"});\n\nlet nameBar = myMap.get("bar")?.name;\nconsole.log(nameBar)   // undefined\n')])])]),n("p",[n("strong",[t._v("可选链操作符的短路计算")])]),t._v(" "),n("p",[t._v("当在表达式中使用可选链时，如果左操作数是 null 或 undefined，表达式将不会被计算，例如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let potentiallyNullObj = null;\nlet x = 0;\nlet prop = potentiallyNullObj?.[x++];\n\nconsole.log(x); // x 将不会被递增，依旧输出 0\n")])])]),n("p",[n("strong",[t._v("使用空值合并操作符")])]),t._v(" "),n("p",[t._v("空值合并操作符可以在使用可选链时设置一个默认值：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let customer = {\n  name: "Carl",\n  details: { age: 82 }\n};\nlet customerCity = customer?.city ?? "何小帅";\nconsole.log(customerCity); // “何小帅”\n')])])]),n("h2",{attrs:{id:"_6、class-类的理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6、class-类的理解"}},[t._v("#")]),t._v(" 6、Class 类的理解")]),t._v(" "),n("p",[n("strong",[t._v("定义：")]),t._v(" ES6 新引入的类概念，作为对象的模版，可通过 calss 定义类。"),n("br"),t._v(" "),n("strong",[t._v("原理：")]),t._v(" 类本身指向构造函数，所有方法定义在 prototype 上，可看作构造函数的另一种写法(Class === Class.prototype.constructor)")]),t._v(" "),n("h4",{attrs:{id:"方法和关键字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法和关键字"}},[t._v("#")]),t._v(" 方法和关键字")]),t._v(" "),n("p",[n("strong",[t._v("constructor()：")]),n("br"),t._v("\n构造方法，new 命令生成实例时自动调用 。类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加，类必须使用 new 调用。 this 指向实例对象。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('   class testClass {\n      constructor() {\n        this.name = "hyp";\n        this.id = 100;\n      }\n    }\n    let testData = new testClass();\n    console.log(testData);\n')])])]),n("p",[t._v("实例属性除了定义在 constructor()方法里面的 this 上面，也可以定义在类的最顶层")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class testClass {\n      name = "hyp";\n      id = 100;\n    }\n    let testData = new testClass();\n    console.log(testData);\n')])])]),n("p",[t._v("新写法能清楚的看出该类中的实例属性")]),t._v(" "),n("p",[n("strong",[t._v("extends：")]),n("br"),t._v("\n继承父类")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(' class testClass {\n      name = "hyp";\n      id = 100;\n    }\n    new testClass();\n    class Child extends testClass {} // 继承了testClass父类实例\n    let child = new Child();\n    console.log(child);\n\n')])])]),n("p",[n("strong",[t._v("super：")]),n("br"),t._v("\n新建父类的 this,子类使用父类的属性方法时，必须在构造函数中调用 super()，否则得不到父类的 this，\n父类静态属性方法可被子类继承,子类继承父类后，可从 super 上调用父类静态属性方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class testClass {\n      name = "hyp";\n      id = 100;\n    }\n    new testClass();\n    class Child extends testClass {\n      constructor() {\n        super(); // 相当于Parent.call(this)\n        this.name = "child";\n      }\n    } // 继承了testClass父类实例\n    let child = new Child();\n    console.log(child);\n')])])]),n("p",[n("strong",[t._v("static：")]),n("br"),t._v("\n定义静态属性方法，不会被实例继承，需通过类来调用。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class testClass {\n      name = "hyp";\n      id = 100;\n      static a() {\n        return 1;\n      }\n    }\n    class Child extends testClass {\n      constructor() {\n        super();\n        this.name = "child";\n      }\n      static b() {\n        return testClass.a() + super.a();\n      }\n    }\n    console.log(Child.b());\n')])])]),n("p",[t._v("私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(' class Parent {\n      // 私有属性最新写法\n      #name1 = "zs";\n      #name2 = "ls";\n      // 私有属性\n      constructor() {\n        this.name = "parent";\n        this.age = "40";\n      }\n      static s = 900;\n      // 静态方法\n      static b() {\n        return 2;\n      }\n    }\n')])])]),n("blockquote",[n("p",[t._v("之所以要引入一个新的前缀#表示私有属性，而没有采用 private 关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator")])]),t._v(" "),n("p",[n("strong",[t._v("get：")]),n("br"),t._v("\n取值函数，拦截属性的取值行为"),n("br"),t._v(" "),n("strong",[t._v("set：")]),n("br"),t._v("\n存值函数，拦截属性的存值行为")]),t._v(" "),n("h4",{attrs:{id:"立即执行写法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#立即执行写法"}},[t._v("#")]),t._v(" 立即执行写法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(' // 立即执行\n    let person = new (class {\n      constructor(name) {\n        this.name = name;\n      }\n\n      sayName() {\n        console.log(this.name);\n      }\n    })("张三");\n    person.sayName();\n\n')])])]),n("h4",{attrs:{id:"generator-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#generator-方法"}},[t._v("#")]),t._v(" Generator 方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('    // Generator 方法\n    class Foo {\n      constructor(...args) {\n        this.args = args;\n      }\n      *[Symbol.iterator]() {\n        for (let arg of this.args) {\n          yield arg;\n        }\n      }\n    }\n\n    for (let x of new Foo("hello", "world")) {\n      console.log(x);\n    }\n')])])]),n("h2",{attrs:{id:"_7、set-实例的属性和方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7、set-实例的属性和方法"}},[t._v("#")]),t._v(" 7、Set 实例的属性和方法")]),t._v(" "),n("p",[t._v("Set 结构的实例有以下属性。")]),t._v(" "),n("blockquote",[n("p",[t._v("Set.prototype.constructor：构造函数，默认就是Set函数。"),n("br"),t._v("\nSet.prototype.size：返回Set实例的成员总数。")])]),t._v(" "),n("p",[n("strong",[t._v("Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）")]),t._v("。")]),t._v(" "),n("h4",{attrs:{id:"_1、四个操作方法。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、四个操作方法。"}},[t._v("#")]),t._v(" 1、四个操作方法。")]),t._v(" "),n("blockquote",[n("p",[t._v("Set.prototype.add(value)：添加某个值，返回 Set 结构本身。"),n("br"),t._v("\nSet.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。"),n("br"),t._v("\nSet.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。"),n("br"),t._v("\nSet.prototype.clear()：清除所有成员，没有返回值。")])]),t._v(" "),n("h4",{attrs:{id:"_2、四个遍历方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、四个遍历方法"}},[t._v("#")]),t._v(" 2、四个遍历方法")]),t._v(" "),n("blockquote",[n("p",[t._v("Set.prototype.keys()：返回键名的遍历器"),n("br"),t._v("\nSet.prototype.values()：返回键值的遍历器"),n("br"),t._v("\nSet.prototype.entries()：返回键值对的遍历器"),n("br"),t._v("\nSet.prototype.forEach()：使用回调函数遍历每个成员")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let set = new Set([\'red\', \'green\', \'blue\']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// ["red", "red"]\n// ["green", "green"]\n// ["blue", "blue"]\n')])])]),n("h2",{attrs:{id:"_8、reduce-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8、reduce-方法"}},[t._v("#")]),t._v(" 8、reduce()方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("arr.reduce(callback(accumulator, currentValue, index, array), initialValue)\n")])])]),n("p",[n("strong",[t._v("参数")]),n("br"),t._v("\ncallback （执行数组中每个值的函数，包含四个参数）")]),t._v(" "),n("pre",[n("code",[t._v("1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））\n2、currentValue （数组中当前被处理的元素）\n3、index （当前元素在数组中的索引）\n4、array （调用 reduce 的数组）\n")])]),t._v(" "),n("p",[t._v("initialValue （作为第一次调用 callback 的第一个参数。）")]),t._v(" "),n("p",[n("strong",[t._v("使用")]),n("br"),t._v("\n回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。")]),t._v(" "),n("blockquote",[n("p",[t._v("注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const  arr = [1, 2, 3, 4];\nconst sum = arr.reduce(function(prev, cur, index, arr) {\n    console.log(prev, cur, index);\n    return prev + cur;\n}，0) //注意这里设置了初始值\nconsole.log(arr, sum);\n")])])]),n("blockquote",[n("p",[t._v("打印结果："),n("br"),t._v("\n0 1 0"),n("br"),t._v("\n1 2 1"),n("br"),t._v("\n3 3 2"),n("br"),t._v("\n6 4 3"),n("br"),t._v("\n[1, 2, 3, 4] 10")])]),t._v(" "),n("p",[n("strong",[t._v("具体使用场景")]),t._v("\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#%E8%AF%AD%E6%B3%95")]),t._v(" "),n("h2",{attrs:{id:"_9、promise-对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9、promise-对象"}},[t._v("#")]),t._v(" 9、Promise 对象")]),t._v(" "),n("p",[n("strong",[t._v("1、Promise解决了什么问题？")])]),t._v(" "),n("p",[t._v("主要解决的是异步编程的问题。在之前的写法中我们都是采用回调函数+事件去解决异步编程的问题，在实际的业务场景中我们可能会写回调中嵌套回调，出现很多的回调函数，造成“回调地狱”，出现代码的可读性差，不易于理解具体的业务逻辑。"),n("br"),t._v("\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。")]),t._v(" "),n("p",[n("strong",[t._v("2、Promise对象的特点？")])]),t._v(" "),n("p",[t._v("Promise对象状态不受外界影响，状态一旦改变就不会再变，任何时候都可以得到这个结果。")]),t._v(" "),n("p",[t._v("Promise对象有三种状态："),n("br"),t._v("\npending（进行中），resolved（已成功），rejected（已失败）")]),t._v(" "),n("p",[t._v("Promise实例具有的方法："),n("br"),t._v("\nthen() 返回resolved状态的回调函数"),n("br"),t._v("\ncatch()  返回rejected状态的回调函数")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const fn = new Promise(function(resolve,reject){\n        let rel = {\n          code:200,\n          data:{\n            name:"何小鹏",\n            age:18\n          }\n        };\n        if (rel.code === 200) {\n          resolve(rel.data)\n        }else{\n          reject("出错了")\n        }\n    })\n    fn.then((v)=>console.log(v)).catch((e)=>console.log(e));\n    // {name: \'何小鹏\', age: 18}\n')])])]),n("p",[t._v("finally() 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作"),n("br"),t._v("\nall()  方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。"),n("br"),t._v("\nrace() 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。和all()方法相似。"),n("br"),t._v("\nallSettled()Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例")])])}),[],!1,null,null,null);e.default=s.exports}}]);