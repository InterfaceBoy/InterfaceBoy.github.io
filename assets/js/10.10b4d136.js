(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{61:function(t,a,r){"use strict";r.r(a);var n=r(0),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"第一题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一题"}},[t._v("#")]),t._v(" 第一题")]),t._v(" "),r("h4",{attrs:{id:"题目描述："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#题目描述："}},[t._v("#")]),t._v(" 题目描述：")]),t._v(" "),r("blockquote",[r("p",[t._v("给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。"),r("br"),t._v("\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。")])]),t._v(" "),r("h4",{attrs:{id:"示例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),r("blockquote",[r("p",[t._v("给定 nums = [2, 7, 11, 15], target = 9"),r("br"),t._v("\n因为 nums[0] + nums[1] = 2 + 7 = 9"),r("br"),t._v("\n所以返回 [0, 1]")])]),t._v(" "),r("h4",{attrs:{id:"解题思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),r("blockquote",[r("p",[t._v("最容易想到的就是暴力枚举，我们可以利用两层 for 循环来遍历每个元素，并查找满足条件的目标元素。不过这样时间复杂度为 O(N^2)，空间复杂度为 O(1)，时间复杂度较高，我们要想办法进行优化。我们可以增加一个 Map 记录已经遍历过的数字及其对应的索引值。这样当遍历一个新数字的时候去 Map 里查询，target 与该数的差值是否已经在前面的数字中出现过。如果出现过，那么已经得出答案，就不必再往下执行了。")])]),t._v(" "),r("h4",{attrs:{id:"解题技巧"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解题技巧"}},[t._v("#")]),t._v(" 解题技巧")]),t._v(" "),r("blockquote",[r("p",[t._v("1、求和转换为求差"),r("br"),t._v("\n2、借助 Map 结构将数组中每个元素及其索引相互对应"),r("br"),t._v("\n3、以空间换时间，将查找时间从 O(N) 降低到 O(1)")])]),t._v(" "),r("h4",{attrs:{id:"代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[t._v("#")]),t._v(" 代码")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const twoSum = function (nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const diff = target - nums[i];\n        if (map.has(diff)) {\n            return [map.get(diff), i];\n        }\n        map.set(nums[i], i);\n    }\n}\n")])])]),r("h2",{attrs:{id:"第二题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二题"}},[t._v("#")]),t._v(" 第二题")]),t._v(" "),r("blockquote",[r("p",[t._v("给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明:  叶子节点是指没有子节点的节点。")])]),t._v(" "),r("h4",{attrs:{id:"示例-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),r("p",[t._v("给定二叉树 [3,9,20,null,null,15,7]，")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("    3\n   / \\\n  9  20\n    /  \\\n   15   7\n")])])]),r("h4",{attrs:{id:"解题思路-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),r("p",[t._v("由于树是一种递归的数据结构")]),t._v(" "),r("h4",{attrs:{id:"解题技巧-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解题技巧-2"}},[t._v("#")]),t._v(" 解题技巧")]),t._v(" "),r("blockquote",[r("p",[t._v("1、队列中用 Null(一个特殊元素)来划分每层，或者在对每层进行迭代之前保存当前队列元素的个数（即当前层所含元素个数）"),r("br"),t._v("\n2、树的基本操作- 遍历 - 层次遍历（BFS）")])]),t._v(" "),r("h4",{attrs:{id:"代码-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代码-2"}},[t._v("#")]),t._v(" 代码")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n  if (!root) return 0;\n  if (!root.left && !root.right) return 1;\n\n  // 层次遍历 BFS\n  let cur = root;\n  const queue = [root, null];\n  let depth = 1;\n\n  while ((cur = queue.shift()) !== undefined) {\n    if (cur === null) {\n      // 注意⚠️： 不处理会无限循环，进而堆栈溢出\n      if (queue.length === 0) return depth;\n      depth++;\n      queue.push(null);\n      continue;\n    }\n    const l = cur.left;\n    const r = cur.right;\n\n    if (l) queue.push(l);\n    if (r) queue.push(r);\n  }\n\n  return depth;\n};\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);