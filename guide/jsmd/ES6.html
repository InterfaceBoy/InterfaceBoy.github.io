<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>日拱一卒无有尽，功不唐捐终入海</title>
    <meta name="description" content="何元鹏">
    
    
    <link rel="preload" href="/assets/css/0.styles.54851b14.css" as="style"><link rel="preload" href="/assets/js/app.26183d58.js" as="script"><link rel="preload" href="/assets/js/2.e57cddc8.js" as="script"><link rel="preload" href="/assets/js/13.9c4c3b55.js" as="script"><link rel="prefetch" href="/assets/js/10.10b4d136.js"><link rel="prefetch" href="/assets/js/11.8ba9850b.js"><link rel="prefetch" href="/assets/js/12.32ec6ad9.js"><link rel="prefetch" href="/assets/js/14.64ac4753.js"><link rel="prefetch" href="/assets/js/15.8b00143b.js"><link rel="prefetch" href="/assets/js/16.e1cc5a03.js"><link rel="prefetch" href="/assets/js/17.22f6c85c.js"><link rel="prefetch" href="/assets/js/18.8ff821f4.js"><link rel="prefetch" href="/assets/js/19.12aa189b.js"><link rel="prefetch" href="/assets/js/20.9f39d968.js"><link rel="prefetch" href="/assets/js/21.7ac61294.js"><link rel="prefetch" href="/assets/js/22.65157c2e.js"><link rel="prefetch" href="/assets/js/23.7d6916b7.js"><link rel="prefetch" href="/assets/js/24.65db4685.js"><link rel="prefetch" href="/assets/js/25.555f89ec.js"><link rel="prefetch" href="/assets/js/26.af1bfc3b.js"><link rel="prefetch" href="/assets/js/27.d661cc97.js"><link rel="prefetch" href="/assets/js/28.b253968c.js"><link rel="prefetch" href="/assets/js/29.ed8fa68a.js"><link rel="prefetch" href="/assets/js/3.ce76472e.js"><link rel="prefetch" href="/assets/js/30.c2efa0a3.js"><link rel="prefetch" href="/assets/js/31.1d825ebf.js"><link rel="prefetch" href="/assets/js/32.2a68a03e.js"><link rel="prefetch" href="/assets/js/4.71ab0d48.js"><link rel="prefetch" href="/assets/js/5.045e847f.js"><link rel="prefetch" href="/assets/js/6.a6d59be0.js"><link rel="prefetch" href="/assets/js/7.d1387d37.js"><link rel="prefetch" href="/assets/js/8.ebe8911c.js"><link rel="prefetch" href="/assets/js/9.ced2f8d4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.54851b14.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">日拱一卒无有尽，功不唐捐终入海</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://www.jianshu.com/u/d90be3fdd9c5" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/InterfaceBoy" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://www.jianshu.com/u/d90be3fdd9c5" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/InterfaceBoy" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">首页</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>html基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>日常总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/jsmd/ES6.html" class="active sidebar-link">ES6语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_1、判断-javascript-数据类型" class="sidebar-link">1、判断 JavaScript 数据类型</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_2、隐式类型转换以及转换原则" class="sidebar-link">2、隐式类型转换以及转换原则</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_3、instanceof-解析" class="sidebar-link">3、instanceof 解析</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_4、逻辑运算符（-和-）-的使用" class="sidebar-link">4、逻辑运算符（|| 和 &amp;&amp;） 的使用</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_5、强大javascript运算符" class="sidebar-link">5、强大JavaScript运算符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_1、多重三元运算（？：）" class="sidebar-link">1、多重三元运算（？：）</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_2、-非空运算符（-）" class="sidebar-link">2、 非空运算符（??）</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_3、逻辑空赋值" class="sidebar-link">3、逻辑空赋值 (??=)</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_4、可选链操作符" class="sidebar-link">4、可选链操作符(?.)</a></li></ul></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_6、class-类的理解" class="sidebar-link">6、Class 类的理解</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_7、set-实例的属性和方法" class="sidebar-link">7、Set 实例的属性和方法</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_8、reduce-方法" class="sidebar-link">8、reduce()方法</a></li><li class="sidebar-sub-header"><a href="/guide/jsmd/ES6.html#_9、promise-对象" class="sidebar-link">9、Promise 对象</a></li></ul></li><li><a href="/guide/jsmd/Skill.html" class="sidebar-link">优化技巧</a></li><li><a href="/guide/jsmd/Design.html" class="sidebar-link">设计模式笔记</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Ts语法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试准备</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>每日算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NodeJS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工作流</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实施监督系统</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="es6-语法"><a href="#es6-语法" class="header-anchor">#</a> es6 语法</h1> <h2 id="_1、判断-javascript-数据类型"><a href="#_1、判断-javascript-数据类型" class="header-anchor">#</a> 1、判断 JavaScript 数据类型</h2> <blockquote><p>1、typeof()函数</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code> console.log(
        typeof 1, //number
        typeof &quot;1&quot;, //string
        typeof true, //boolean
        typeof undefined, //undefined
        typeof null // object
      );
</code></pre></div><p><strong>因为 typeof null 返回的是 object，但是 null 这个是 string 类型的，没法用来区分引用数据类型，所以 typeof 一般都是用于判断值类型数据（number，string，boolean，undefined）</strong></p> <blockquote><p>2、instanceof 方法</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code> let obj = {};
      obj instanceof Object; //true

      let arr = [];
      arr instanceof Array; //true

      let now = new Date();
      now instanceof Date; //true

      let func = function() {};
      func instanceof Function; //true

      let str = &quot;string&quot;;
      let PDstr = str instanceof String; //false
      console.log(PDstr);
</code></pre></div><p><strong>因为上面例子中 PDstr 返回的是 false，但是这个实例又是 string 类型的，所以无法对值类型进行判断，instanceof 一般用来判断一个变量是否是某个对象的实例，所以对于引用类型我们使用 instanceof 来进行类型判断。</strong></p> <blockquote><p>3、Object.prototype.toString.call()</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let num1 = 1;
      let num2 = new Number(1);
      let numB = Object.prototype.toString.call(num1) == &quot;[object Number]&quot;; //true
      Object.prototype.toString.call(num2) == &quot;[object Number]&quot;; //true
      console.log(numB);
      let att = [];
      Object.prototype.toString.call(att) == &quot;[object Array]&quot;; //true

      let attf = function() {};
      let attfFn = Object.prototype.toString.call(attf) == &quot;[object Function]&quot;; //true
      console.log(attfFn);

      function A() {}
      let a = new A();
      Object.prototype.toString.call(a) == &quot;[object Object]&quot;; //true
</code></pre></div><p><strong>在 javascript 高级程序设计中提供了另一种方法，可以通用的来判断原始数据类型和引用数据类型</strong></p> <blockquote><p>4、constructor</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code> console.log(&quot;constructor&quot;, [].constructor === Array);
      console.log({}.constructor === Object);
      console.log(&quot;string&quot;.constructor === String);
      console.log((123).constructor === Number);
      console.log(true.constructor === Boolean);
</code></pre></div><p><strong>属性返回对创建此对象的数组函数的引用,就是返回对象相对应的构造函数。原因：constructor 是 prototype 对象上的属性，指向构造函数。</strong></p> <h2 id="_2、隐式类型转换以及转换原则"><a href="#_2、隐式类型转换以及转换原则" class="header-anchor">#</a> 2、隐式类型转换以及转换原则</h2> <p>最常见的隐式类型转换主要是 boolead 转换</p> <div class="language- extra-class"><pre class="language-text"><code>  let test;
      test = null;
      if (!test) {
        console.log(&quot;非空字符串会转换成true，空字符串会转换成false&quot;, !test);
      }
      test = &quot;&quot;;
      if (!test) {
        console.log(&quot;''和null都是空字符串&quot;, !test);
      }
      test = 0;
      if (!test) {
        console.log(&quot;非0会转换成true，0会转换成false&quot;, !test);
      }
      test = {};
      if (test) {
        console.log(&quot;任何对象都会转成true&quot;, !test);
      }
</code></pre></div><blockquote><p>1、String，非空字符串会转换成 true，空字符串会转换成 false<br>
2、Number, 非 0 会转换成 true，0 会转换成 false<br>
3、Object，任何对象都会转成 true</p></blockquote> <h2 id="_3、instanceof-解析"><a href="#_3、instanceof-解析" class="header-anchor">#</a> 3、instanceof 解析</h2> <div class="language- extra-class"><pre class="language-text"><code>function instance_of(L, R) { // L即stu ；  R即Person

  const O = R.prototype; // O为Person.prototype

   L = L.__proto__;   //L为stu._proto_，现在指向的是per实例对象

   while (true) {   // 执行循环

      if (L === null)   //不通过

          return false;

      if (O === L)    //判断：   Person.prototype === stu._proto_ ？

           return true;   //此时，stu._proto_ 指向per实例对象，并不满足

       L = L.__proto__;  //令L=  stu._proto_._proto_，执行循环

  }                      //stu._proto_ ._proto_，看图示知：

}
</code></pre></div><h2 id="_4、逻辑运算符（-和-）-的使用"><a href="#_4、逻辑运算符（-和-）-的使用" class="header-anchor">#</a> 4、逻辑运算符（|| 和 &amp;&amp;） 的使用</h2> <p><strong>定义：</strong> &amp;&amp;是“与”的意思，||是“或者”的意思</p> <p><strong>使用方式：</strong> a &amp;&amp; b：a 和 b 同时为 true 才返回 true， 否则返回 false；a || b：a 或 b 任意一个为 true 就返回 true ， 否则返回 false</p> <p><strong>运算方式：</strong> 都表示运算，但是&amp;&amp;运算符第一个表达式不成立的话，后面的表达式不运算，直接返回。而&amp;对所有表达式都得判断。</p> <div class="language- extra-class"><pre class="language-text"><code>  let judgingType = screeningType.some(item =&gt; {
        return (
          (data.indicator === &quot;&quot; &amp;&amp; item.value !== &quot;&quot;) ||
          (data.indicator === undefined &amp;&amp; item.value !== &quot;&quot;)
        );
      });
</code></pre></div><h2 id="_5、强大javascript运算符"><a href="#_5、强大javascript运算符" class="header-anchor">#</a> 5、强大JavaScript运算符</h2> <h3 id="_1、多重三元运算（？：）"><a href="#_1、多重三元运算（？：）" class="header-anchor">#</a> 1、多重三元运算（？：）</h3> <div class="language- extra-class"><pre class="language-text"><code>const size = val =&gt;
  Array.isArray(val)
    ? val.length
    : val &amp;&amp; typeof val === 'object'
    ? val.size || val.length || Object.keys(val).length
    : typeof val === 'string'
    ? new Blob([val]).size
    : 0;

size([1, 2, 3, 4, 5]); // 5
size('yuan'); // 4
size({ one: 1, two: 2, three: 3 }); // 3
</code></pre></div><p><strong>这个的实现非常巧妙，利用 Blob 类文件对象的特性，获取对象的长度。</strong></p> <h3 id="_2、-非空运算符（-）"><a href="#_2、-非空运算符（-）" class="header-anchor">#</a> 2、 非空运算符（??）</h3> <p>?? 运算符被称为非空运算符。<br>
如果第一个参数不是 null/undefined，将返回第一个参数，否则返回第二个参数</p> <div class="language- extra-class"><pre class="language-text"><code>null ?? 5
// 5
3 ?? 4
// 3
</code></pre></div><p><strong>注意这里的假值只是 null/undefined</strong></p> <h3 id="_3、逻辑空赋值"><a href="#_3、逻辑空赋值" class="header-anchor">#</a> 3、逻辑空赋值 (??=)</h3> <p>逻辑空赋值运算符 (x ??= y) 仅在 x 是 null 或 undefined时对其赋值。</p> <div class="language- extra-class"><pre class="language-text"><code>const a = { duration: 50 };

a.duration ??= 10;
console.log(a.duration);
// expected output: 50

a.speed ??= 25;
console.log(a.speed);
// expected output: 25

</code></pre></div><p>??= 可用来初始化缺失的属性</p> <div class="language- extra-class"><pre class="language-text"><code>const pages = [
  {
    title:'主要场景',
    path:'/'
  },
  {
    path:'/a'
  },
  {
    path:'/b'
  },
]

for (const page of pages){
    page.title ??= '默认标题'
}

console.table(pages)
//(index)   title          path
//0        &quot;主要场景&quot;       &quot;/&quot;
//1        &quot;默认标题&quot;       &quot;/a&quot;
//2        &quot;默认标题&quot;       &quot;/b&quot;
</code></pre></div><p>空赋值的短路用法<br> <strong>空值合并运算符从左至右求值</strong></p> <blockquote><p>(结果非 null 或 undefined 的表达式) ?? expr 被短路求值为左侧表达式，当左侧证明为既非 null 也非 undefined.</p></blockquote> <blockquote><p>语法短路意味着 expr 部分尚未被求值，因此任何与其求值产生的相关副作用都不会生效（例如，如果 expr 是一个函数调用，则该调用将不会发生）。</p></blockquote> <p>逻辑空赋值的语法短路也意味着 x ??= y 等价于：</p> <blockquote><p>x ?? (x = y);</p></blockquote> <p>而不等价于如下的表达式，因为其一定会发生赋值：</p> <blockquote><p>x = x ?? y;</p></blockquote> <p>在使用??=时，这里的假值只是 null/undefined</p> <p><strong>逻辑运算||=</strong></p> <p>在||=中判断的假值可以是''/null/undefined/0</p> <div class="language- extra-class"><pre class="language-text"><code>const a = { duration: 50, title: '' };

a.duration ||= 10;
console.log(a.duration);
// expected output: 50

a.title ||= 'title is empty.';
console.log(a.title);
// expected output: &quot;title is empty&quot;
</code></pre></div><p><strong>赋值表达式</strong></p> <div class="language- extra-class"><pre class="language-text"><code>a ||= b
//等价于
a = a || (a = b)

a &amp;&amp;= b
//等价于
a = a &amp;&amp; (a = b)

a ??= b
//等价于
a = a ?? (a = b)
</code></pre></div><p><strong>注意：</strong></p> <blockquote><p>a ||= b：当a值不存在时，将b变量赋值给a<br>
a &amp;&amp;= b：当a值存在时，将b变量赋值给a<br>
a ??= b：当a值为null或者undefined时，将b变量赋值给a</p></blockquote> <h3 id="_4、可选链操作符"><a href="#_4、可选链操作符" class="header-anchor">#</a> 4、可选链操作符(?.)</h3> <p>通过使用 ?. 操作符取代 . 操作符，JavaScript 会在尝试访问 obj.first.second 之前，先隐式地检查并确定 obj.first 既不是 null 也不是 undefined。如果obj.first 是 null 或者 undefined，表达式将会短路计算直接返回 undefined。</p> <div class="language- extra-class"><pre class="language-text"><code>const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah'
  }
};

const dogName = adventurer.cat?.name;
console.log(dogName);
// expected output: Dinah

console.log(adventurer.cat?.age);
// expected output: undefined
</code></pre></div><p>如果在对象的每一层都需要判断</p> <div class="language- extra-class"><pre class="language-text"><code>adventurer?.set?.age
</code></pre></div><p><strong>在Map中使用可选链操作符</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let myMap = new Map();
myMap.set(&quot;foo&quot;, {name: &quot;baz&quot;, desc: &quot;inga&quot;});

let nameBar = myMap.get(&quot;bar&quot;)?.name;
console.log(nameBar)   // undefined
</code></pre></div><p><strong>可选链操作符的短路计算</strong></p> <p>当在表达式中使用可选链时，如果左操作数是 null 或 undefined，表达式将不会被计算，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>let potentiallyNullObj = null;
let x = 0;
let prop = potentiallyNullObj?.[x++];

console.log(x); // x 将不会被递增，依旧输出 0
</code></pre></div><p><strong>使用空值合并操作符</strong></p> <p>空值合并操作符可以在使用可选链时设置一个默认值：</p> <div class="language- extra-class"><pre class="language-text"><code>let customer = {
  name: &quot;Carl&quot;,
  details: { age: 82 }
};
let customerCity = customer?.city ?? &quot;何小帅&quot;;
console.log(customerCity); // “何小帅”
</code></pre></div><h2 id="_6、class-类的理解"><a href="#_6、class-类的理解" class="header-anchor">#</a> 6、Class 类的理解</h2> <p><strong>定义：</strong> ES6 新引入的类概念，作为对象的模版，可通过 calss 定义类。<br> <strong>原理：</strong> 类本身指向构造函数，所有方法定义在 prototype 上，可看作构造函数的另一种写法(Class === Class.prototype.constructor)</p> <h4 id="方法和关键字"><a href="#方法和关键字" class="header-anchor">#</a> 方法和关键字</h4> <p><strong>constructor()：</strong><br>
构造方法，new 命令生成实例时自动调用 。类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加，类必须使用 new 调用。 this 指向实例对象。</p> <div class="language- extra-class"><pre class="language-text"><code>   class testClass {
      constructor() {
        this.name = &quot;hyp&quot;;
        this.id = 100;
      }
    }
    let testData = new testClass();
    console.log(testData);
</code></pre></div><p>实例属性除了定义在 constructor()方法里面的 this 上面，也可以定义在类的最顶层</p> <div class="language- extra-class"><pre class="language-text"><code>class testClass {
      name = &quot;hyp&quot;;
      id = 100;
    }
    let testData = new testClass();
    console.log(testData);
</code></pre></div><p>新写法能清楚的看出该类中的实例属性</p> <p><strong>extends：</strong><br>
继承父类</p> <div class="language- extra-class"><pre class="language-text"><code> class testClass {
      name = &quot;hyp&quot;;
      id = 100;
    }
    new testClass();
    class Child extends testClass {} // 继承了testClass父类实例
    let child = new Child();
    console.log(child);

</code></pre></div><p><strong>super：</strong><br>
新建父类的 this,子类使用父类的属性方法时，必须在构造函数中调用 super()，否则得不到父类的 this，
父类静态属性方法可被子类继承,子类继承父类后，可从 super 上调用父类静态属性方法</p> <div class="language- extra-class"><pre class="language-text"><code>class testClass {
      name = &quot;hyp&quot;;
      id = 100;
    }
    new testClass();
    class Child extends testClass {
      constructor() {
        super(); // 相当于Parent.call(this)
        this.name = &quot;child&quot;;
      }
    } // 继承了testClass父类实例
    let child = new Child();
    console.log(child);
</code></pre></div><p><strong>static：</strong><br>
定义静态属性方法，不会被实例继承，需通过类来调用。</p> <div class="language- extra-class"><pre class="language-text"><code>class testClass {
      name = &quot;hyp&quot;;
      id = 100;
      static a() {
        return 1;
      }
    }
    class Child extends testClass {
      constructor() {
        super();
        this.name = &quot;child&quot;;
      }
      static b() {
        return testClass.a() + super.a();
      }
    }
    console.log(Child.b());
</code></pre></div><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装</p> <div class="language- extra-class"><pre class="language-text"><code> class Parent {
      // 私有属性最新写法
      #name1 = &quot;zs&quot;;
      #name2 = &quot;ls&quot;;
      // 私有属性
      constructor() {
        this.name = &quot;parent&quot;;
        this.age = &quot;40&quot;;
      }
      static s = 900;
      // 静态方法
      static b() {
        return 2;
      }
    }
</code></pre></div><blockquote><p>之所以要引入一个新的前缀#表示私有属性，而没有采用 private 关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator</p></blockquote> <p><strong>get：</strong><br>
取值函数，拦截属性的取值行为<br> <strong>set：</strong><br>
存值函数，拦截属性的存值行为</p> <h4 id="立即执行写法"><a href="#立即执行写法" class="header-anchor">#</a> 立即执行写法</h4> <div class="language- extra-class"><pre class="language-text"><code> // 立即执行
    let person = new (class {
      constructor(name) {
        this.name = name;
      }

      sayName() {
        console.log(this.name);
      }
    })(&quot;张三&quot;);
    person.sayName();

</code></pre></div><h4 id="generator-方法"><a href="#generator-方法" class="header-anchor">#</a> Generator 方法</h4> <div class="language- extra-class"><pre class="language-text"><code>    // Generator 方法
    class Foo {
      constructor(...args) {
        this.args = args;
      }
      *[Symbol.iterator]() {
        for (let arg of this.args) {
          yield arg;
        }
      }
    }

    for (let x of new Foo(&quot;hello&quot;, &quot;world&quot;)) {
      console.log(x);
    }
</code></pre></div><h2 id="_7、set-实例的属性和方法"><a href="#_7、set-实例的属性和方法" class="header-anchor">#</a> 7、Set 实例的属性和方法</h2> <p>Set 结构的实例有以下属性。</p> <blockquote><p>Set.prototype.constructor：构造函数，默认就是Set函数。<br>
Set.prototype.size：返回Set实例的成员总数。</p></blockquote> <p><strong>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）</strong>。</p> <h4 id="_1、四个操作方法。"><a href="#_1、四个操作方法。" class="header-anchor">#</a> 1、四个操作方法。</h4> <blockquote><p>Set.prototype.add(value)：添加某个值，返回 Set 结构本身。<br>
Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>
Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。<br>
Set.prototype.clear()：清除所有成员，没有返回值。</p></blockquote> <h4 id="_2、四个遍历方法"><a href="#_2、四个遍历方法" class="header-anchor">#</a> 2、四个遍历方法</h4> <blockquote><p>Set.prototype.keys()：返回键名的遍历器<br>
Set.prototype.values()：返回键值的遍历器<br>
Set.prototype.entries()：返回键值对的遍历器<br>
Set.prototype.forEach()：使用回调函数遍历每个成员</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
</code></pre></div><h2 id="_8、reduce-方法"><a href="#_8、reduce-方法" class="header-anchor">#</a> 8、reduce()方法</h2> <div class="language- extra-class"><pre class="language-text"><code>arr.reduce(callback(accumulator, currentValue, index, array), initialValue)
</code></pre></div><p><strong>参数</strong><br>
callback （执行数组中每个值的函数，包含四个参数）</p> <pre><code>1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
2、currentValue （数组中当前被处理的元素）
3、index （当前元素在数组中的索引）
4、array （调用 reduce 的数组）
</code></pre> <p>initialValue （作为第一次调用 callback 的第一个参数。）</p> <p><strong>使用</strong><br>
回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。</p> <blockquote><p>注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const  arr = [1, 2, 3, 4];
const sum = arr.reduce(function(prev, cur, index, arr) {
    console.log(prev, cur, index);
    return prev + cur;
}，0) //注意这里设置了初始值
console.log(arr, sum);
</code></pre></div><blockquote><p>打印结果：<br>
0 1 0<br>
1 2 1<br>
3 3 2<br>
6 4 3<br>
[1, 2, 3, 4] 10</p></blockquote> <p><strong>具体使用场景</strong>
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#%E8%AF%AD%E6%B3%95</p> <h2 id="_9、promise-对象"><a href="#_9、promise-对象" class="header-anchor">#</a> 9、Promise 对象</h2> <p><strong>1、Promise解决了什么问题？</strong></p> <p>主要解决的是异步编程的问题。在之前的写法中我们都是采用回调函数+事件去解决异步编程的问题，在实际的业务场景中我们可能会写回调中嵌套回调，出现很多的回调函数，造成“回调地狱”，出现代码的可读性差，不易于理解具体的业务逻辑。<br>
有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p> <p><strong>2、Promise对象的特点？</strong></p> <p>Promise对象状态不受外界影响，状态一旦改变就不会再变，任何时候都可以得到这个结果。</p> <p>Promise对象有三种状态：<br>
pending（进行中），resolved（已成功），rejected（已失败）</p> <p>Promise实例具有的方法：<br>
then() 返回resolved状态的回调函数<br>
catch()  返回rejected状态的回调函数</p> <div class="language- extra-class"><pre class="language-text"><code>const fn = new Promise(function(resolve,reject){
        let rel = {
          code:200,
          data:{
            name:&quot;何小鹏&quot;,
            age:18
          }
        };
        if (rel.code === 200) {
          resolve(rel.data)
        }else{
          reject(&quot;出错了&quot;)
        }
    })
    fn.then((v)=&gt;console.log(v)).catch((e)=&gt;console.log(e));
    // {name: '何小鹏', age: 18}
</code></pre></div><p>finally() 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作<br>
all()  方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>
race() 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。和all()方法相似。<br>
allSettled()Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/InterfaceBoy/edit/master/docs/guide/jsmd/ES6.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">何元鹏:</span> <span class="time">11/30/2021, 11:34:01 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/guide/actualCombat/aC2.html" class="prev">基础操作技巧汇总</a></span> <span class="next"><a href="/guide/jsmd/Skill.html">优化技巧</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.26183d58.js" defer></script><script src="/assets/js/2.e57cddc8.js" defer></script><script src="/assets/js/13.9c4c3b55.js" defer></script>
  </body>
</html>
